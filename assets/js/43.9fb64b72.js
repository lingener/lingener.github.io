(window.webpackJsonp=window.webpackJsonp||[]).push([[43],{682:function(s,e,a){"use strict";a.r(e);var v=a(3),t=Object(v.a)({},(function(){var s=this,e=s.$createElement,a=s._self._c||e;return a("ContentSlotsDistributor",{attrs:{"slot-key":s.$parent.slotKey}},[a("h1",{attrs:{id:"redis-基本使用"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#redis-基本使用"}},[s._v("#")]),s._v(" Redis_基本使用")]),s._v(" "),a("h2",{attrs:{id:"命令"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#命令"}},[s._v("#")]),s._v(" 命令")]),s._v(" "),a("h3",{attrs:{id:"使用要点"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#使用要点"}},[s._v("#")]),s._v(" 使用要点")]),s._v(" "),a("ul",[a("li",[s._v("命令中涉及到range操作的都支持正向索引（1,2,3）和负向索引（-1，-2，-3）")]),s._v(" "),a("li",[s._v("Redis虽然提供了很多的命令，但是需要评估每个命令的性能消耗（运行效率、网卡吞吐量）\n"),a("ul",[a("li",[s._v("smembers")]),s._v(" "),a("li",[s._v("keys")])])])]),s._v(" "),a("h3",{attrs:{id:"help命令"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#help命令"}},[s._v("#")]),s._v(" Help命令")]),s._v(" "),a("h3",{attrs:{id:"server"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#server"}},[s._v("#")]),s._v(" @server")]),s._v(" "),a("ul",[a("li",[s._v("config")])]),s._v(" "),a("h3",{attrs:{id:"general"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#general"}},[s._v("#")]),s._v(" @General")]),s._v(" "),a("ul",[a("li",[s._v("type")]),s._v(" "),a("li",[s._v("object")]),s._v(" "),a("li",[s._v("del")]),s._v(" "),a("li",[s._v("dump")]),s._v(" "),a("li",[s._v("exists")]),s._v(" "),a("li",[s._v("expire")]),s._v(" "),a("li",[s._v("expireat")]),s._v(" "),a("li",[s._v("persist")]),s._v(" "),a("li",[s._v("pexpire")]),s._v(" "),a("li",[s._v("pexpireat")]),s._v(" "),a("li",[s._v("pttl")]),s._v(" "),a("li",[s._v("keys")]),s._v(" "),a("li",[s._v("migrate")]),s._v(" "),a("li",[s._v("move")]),s._v(" "),a("li",[s._v("randomkey")]),s._v(" "),a("li",[s._v("rename")]),s._v(" "),a("li",[s._v("renamenx")])]),s._v(" "),a("h3",{attrs:{id:"string"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#string"}},[s._v("#")]),s._v(" @string")]),s._v(" "),a("ul",[a("li",[a("p",[s._v("set")])]),s._v(" "),a("li",[a("p",[s._v("setnx")])]),s._v(" "),a("li",[a("p",[s._v("setex")])]),s._v(" "),a("li",[a("p",[s._v("setrange")])]),s._v(" "),a("li",[a("p",[s._v("msetnx")]),s._v(" "),a("p",[s._v("原子操作")])]),s._v(" "),a("li",[a("p",[s._v("msetex")])]),s._v(" "),a("li",[a("p",[s._v("get")])]),s._v(" "),a("li",[a("p",[s._v("getset")]),s._v(" "),a("p",[s._v("设置新值，返回旧值")])]),s._v(" "),a("li",[a("p",[s._v("getrange")]),s._v(" "),a("div",{staticClass:"language- line-numbers-mode"},[a("pre",{pre:!0,attrs:{class:"language-text"}},[a("code",[s._v("getrange k1 0 -1\n")])]),s._v(" "),a("div",{staticClass:"line-numbers-wrapper"},[a("span",{staticClass:"line-number"},[s._v("1")]),a("br")])])]),s._v(" "),a("li",[a("p",[s._v("append")])]),s._v(" "),a("li",[a("p",[s._v("strlen")])]),s._v(" "),a("li",[a("p",[s._v("incr")])]),s._v(" "),a("li",[a("p",[s._v("incrby")])]),s._v(" "),a("li",[a("p",[s._v("incrbyfloat")])]),s._v(" "),a("li",[a("p",[s._v("decr")])]),s._v(" "),a("li",[a("p",[s._v("decrby")])]),s._v(" "),a("li",[a("p",[s._v("setbit")]),s._v(" "),a("div",{staticClass:"language- line-numbers-mode"},[a("pre",{pre:!0,attrs:{class:"language-text"}},[a("code",[s._v("setbit k1 1 1\nsetbit k1 7 1\nsetbit k1 9 1\n// 字符集  ascii其他一般叫做扩展字符集扩展：  其他字符集不在对ascii重编码0xxxxxxx你自己写一个程序，字节流读取，每字节判断\n")])]),s._v(" "),a("div",{staticClass:"line-numbers-wrapper"},[a("span",{staticClass:"line-number"},[s._v("1")]),a("br"),a("span",{staticClass:"line-number"},[s._v("2")]),a("br"),a("span",{staticClass:"line-number"},[s._v("3")]),a("br"),a("span",{staticClass:"line-number"},[s._v("4")]),a("br")])])]),s._v(" "),a("li",[a("p",[s._v("bitpos")]),s._v(" "),a("p",[s._v("start/end是指字节索引位置")])]),s._v(" "),a("li",[a("p",[s._v("bitcount")])]),s._v(" "),a("li",[a("p",[s._v("bitop")]),s._v(" "),a("div",{staticClass:"language- line-numbers-mode"},[a("pre",{pre:!0,attrs:{class:"language-text"}},[a("code",[s._v("setbit k1 1 1\nsetbit k1 7 1\nsetbit k2 1 1\nsetbit k2 6 1\nbitop and andkey k1 k2\nbitop or orkey k1 k2\n")])]),s._v(" "),a("div",{staticClass:"line-numbers-wrapper"},[a("span",{staticClass:"line-number"},[s._v("1")]),a("br"),a("span",{staticClass:"line-number"},[s._v("2")]),a("br"),a("span",{staticClass:"line-number"},[s._v("3")]),a("br"),a("span",{staticClass:"line-number"},[s._v("4")]),a("br"),a("span",{staticClass:"line-number"},[s._v("5")]),a("br"),a("span",{staticClass:"line-number"},[s._v("6")]),a("br")])])])]),s._v(" "),a("h3",{attrs:{id:"list"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#list"}},[s._v("#")]),s._v(" @list")]),s._v(" "),a("ul",[a("li",[a("p",[s._v("lpush")])]),s._v(" "),a("li",[a("p",[s._v("lpop")])]),s._v(" "),a("li",[a("p",[s._v("rpush")])]),s._v(" "),a("li",[a("p",[s._v("rpop")])]),s._v(" "),a("li",[a("p",[s._v("lrange")]),s._v(" "),a("p",[s._v("lpush")])]),s._v(" "),a("li",[a("p",[s._v("lindex")])]),s._v(" "),a("li",[a("p",[s._v("lset")])]),s._v(" "),a("li",[a("p",[s._v("lrem")]),s._v(" "),a("div",{staticClass:"language- line-numbers-mode"},[a("pre",{pre:!0,attrs:{class:"language-text"}},[a("code",[s._v("lpush k1 a b c d a e f a g\nlrem k1 2 a  // 移除前两个a\nlrem k1 -2 a  // 移除后两个a\n")])]),s._v(" "),a("div",{staticClass:"line-numbers-wrapper"},[a("span",{staticClass:"line-number"},[s._v("1")]),a("br"),a("span",{staticClass:"line-number"},[s._v("2")]),a("br"),a("span",{staticClass:"line-number"},[s._v("3")]),a("br")])])]),s._v(" "),a("li",[a("p",[s._v("linsert")]),s._v(" "),a("div",{staticClass:"language-redis line-numbers-mode"},[a("pre",{pre:!0,attrs:{class:"language-text"}},[a("code",[s._v("lpush k1 a b c d b e\nlinsert k1 after b 6 // 如果有两个是在第一个符合条件的数据进行操作\n")])]),s._v(" "),a("div",{staticClass:"line-numbers-wrapper"},[a("span",{staticClass:"line-number"},[s._v("1")]),a("br"),a("span",{staticClass:"line-number"},[s._v("2")]),a("br")])])]),s._v(" "),a("li",[a("p",[s._v("llen")])]),s._v(" "),a("li",[a("p",[s._v("blpop")])]),s._v(" "),a("li",[a("p",[s._v("ltrim")]),s._v(" "),a("p",[s._v("ltrim k4 0 -1")]),s._v(" "),a("p",[s._v("删除范围外两端的数据")])])]),s._v(" "),a("h3",{attrs:{id:"hash"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#hash"}},[s._v("#")]),s._v(" @hash")]),s._v(" "),a("ul",[a("li",[a("p",[s._v("hdel")])]),s._v(" "),a("li",[a("p",[s._v("hset")])]),s._v(" "),a("li",[a("p",[s._v("hmset")])]),s._v(" "),a("li",[a("p",[s._v("hget")])]),s._v(" "),a("li",[a("p",[s._v("hmget")])]),s._v(" "),a("li",[a("p",[s._v("hkeys")])]),s._v(" "),a("li",[a("p",[s._v("hvals")])]),s._v(" "),a("li",[a("p",[s._v("hgetall")])]),s._v(" "),a("li",[a("p",[s._v("hincrbyfloat")])])]),s._v(" "),a("h3",{attrs:{id:"set"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#set"}},[s._v("#")]),s._v(" @set")]),s._v(" "),a("ul",[a("li",[s._v("sadd")])]),s._v(" "),a("h3",{attrs:{id:"sorted-set"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#sorted-set"}},[s._v("#")]),s._v(" @sorted set")]),s._v(" "),a("h2",{attrs:{id:"管道pipelining"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#管道pipelining"}},[s._v("#")]),s._v(" 管道Pipelining")]),s._v(" "),a("p",[s._v("一次发送多条操作指令，节省往返时间RTT（Round Trip Time）")]),s._v(" "),a("div",{staticClass:"language- line-numbers-mode"},[a("pre",{pre:!0,attrs:{class:"language-text"}},[a("code",[s._v('echo -e "set k2 99\\n incr k2\\n get k2" | nc localhost 6379\n')])]),s._v(" "),a("div",{staticClass:"line-numbers-wrapper"},[a("span",{staticClass:"line-number"},[s._v("1")]),a("br")])]),a("blockquote",[a("p",[s._v("使用管道发送命令时，服务器将被迫回复一个队列答复，占用很多内存。所以，如果你需要发送大量的命令，最好是把他们按照合理数量分批次的处理，例如10K的命令，读回复，然后再发送另一个10k的命令，等等。这样速度几乎是相同的，但是在回复这10k命令队列需要非常大量的内存用来组织返回数据内容")])]),s._v(" "),a("h2",{attrs:{id:"大量插入数据"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#大量插入数据"}},[s._v("#")]),s._v(" 大量插入数据")]),s._v(" "),a("p",[s._v("​\t使用正常模式的Redis 客户端执行大量数据插入不是一个好主意，因为一个个的插入会有大量的时间浪费在每一个命令往返时间上。使用管道（pipelining）是一种可行的办法，但是在大量插入数据的同时又需要执行其他新命令时，这时读取数据的同时需要确保尽可能快的写入数据。")]),s._v(" "),a("p",[s._v("只有一小部分的客户端支持非阻塞输入/输出(non-blocking I/O),并且并不是所有客户端能以最大限度的提高吞吐量的高效的方式来分析答复。")]),s._v(" "),a("p",[s._v("例如，如果我们需要生成一个10亿的"),a("code",[s._v("keyN -> ValueN")]),s._v("的大数据集，我们会创建一个如下的redis命令集的文件data.txt：")]),s._v(" "),a("div",{staticClass:"language- line-numbers-mode"},[a("pre",{pre:!0,attrs:{class:"language-text"}},[a("code",[s._v("SET Key0 Value0\nSET Key1 Value1\n...\nSET KeyN ValueN\n")])]),s._v(" "),a("div",{staticClass:"line-numbers-wrapper"},[a("span",{staticClass:"line-number"},[s._v("1")]),a("br"),a("span",{staticClass:"line-number"},[s._v("2")]),a("br"),a("span",{staticClass:"line-number"},[s._v("3")]),a("br"),a("span",{staticClass:"line-number"},[s._v("4")]),a("br")])]),a("p",[s._v("以前可以使用"),a("strong",[s._v("netcat")]),s._v("的方式，使用方式如下：")]),s._v(" "),a("div",{staticClass:"language- line-numbers-mode"},[a("pre",{pre:!0,attrs:{class:"language-text"}},[a("code",[s._v("(cat data.txt; sleep 10) | nc localhost 6379 > /dev/null\n")])]),s._v(" "),a("div",{staticClass:"line-numbers-wrapper"},[a("span",{staticClass:"line-number"},[s._v("1")]),a("br")])]),a("p",[a("strong",[s._v("然而这并不是一个非常可靠的方式，因为用netcat进行大规模插入时不能检查错误。")])]),s._v(" "),a("p",[s._v("从Redis 2.6开始"),a("code",[s._v("redis-cli")]),s._v("支持一种新的被称之为"),a("strong",[s._v("pipe mode")]),s._v("的新模式用于执行大量数据插入工作。")]),s._v(" "),a("p",[s._v("使用"),a("strong",[s._v("pipe mode")]),s._v("模式的执行命令如下：")]),s._v(" "),a("div",{staticClass:"language- line-numbers-mode"},[a("pre",{pre:!0,attrs:{class:"language-text"}},[a("code",[s._v("cat data.txt | redis-cli --pipe\n")])]),s._v(" "),a("div",{staticClass:"line-numbers-wrapper"},[a("span",{staticClass:"line-number"},[s._v("1")]),a("br")])]),a("p",[s._v("这将产生类似如下的输出：")]),s._v(" "),a("div",{staticClass:"language- line-numbers-mode"},[a("pre",{pre:!0,attrs:{class:"language-text"}},[a("code",[s._v("All data transferred. Waiting for the last reply...\nLast reply received from server.\nerrors: 0, replies: 1000000\n")])]),s._v(" "),a("div",{staticClass:"line-numbers-wrapper"},[a("span",{staticClass:"line-number"},[s._v("1")]),a("br"),a("span",{staticClass:"line-number"},[s._v("2")]),a("br"),a("span",{staticClass:"line-number"},[s._v("3")]),a("br")])]),a("p",[s._v("使用redis-cli将有效的确保错误输出到Redis实例的标准输出里面。")]),s._v(" "),a("h2",{attrs:{id:"pub-sub"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#pub-sub"}},[s._v("#")]),s._v(" Pub/Sub")]),s._v(" "),a("ul",[a("li",[a("p",[s._v("只能收到订阅之后发布的消息")])]),s._v(" "),a("li",[a("p",[s._v("使用案例")]),s._v(" "),a("ul",[a("li",[s._v("聊天系统")])])])]),s._v(" "),a("p",[a("img",{attrs:{src:"/Users/lijinling/Documents/svn/myRepo/Coding/DayDayUp/Middleware/Cache/Redis/images/Redis_案例_聊天.png",alt:"image-20210713121936501"}})]),s._v(" "),a("h2",{attrs:{id:"transactions"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#transactions"}},[s._v("#")]),s._v(" transactions")]),s._v(" "),a("ul",[a("li",[a("p",[s._v("特点")]),s._v(" "),a("ul",[a("li",[s._v("事务是一个单独的隔离操作：事务中的所有命令都会序列化、按顺序地执行。事务在执行的过程中，不会被其他客户端发送来的命令请求所打断。")]),s._v(" "),a("li",[s._v("事务是一个原子操作：事务中的命令要么全部被执行，要么全部都不执行。")])])]),s._v(" "),a("li",[a("p",[s._v("帮助")]),s._v(" "),a("p",[a("code",[s._v("help @transactions")])])]),s._v(" "),a("li",[a("p",[s._v("用法")]),s._v(" "),a("p",[a("code",[s._v("MULTI")]),s._v("、"),a("code",[s._v("EXEC")]),s._v("、"),a("code",[s._v("DISCARD")]),s._v("和"),a("code",[s._v("WATCH")]),s._v("是Redis事务相关的命令。")]),s._v(" "),a("ul",[a("li",[a("p",[a("code",[s._v("MULTI")]),s._v("开启事务")]),s._v(" "),a("ul",[a("li",[s._v("开启事务之后发送的命令会被放到一个队列中")])])]),s._v(" "),a("li",[a("p",[a("code",[s._v("EXCEC")]),s._v("负责触发并执行事务中所有的命令")]),s._v(" "),a("ul",[a("li",[s._v("如果客户端在使用"),a("code",[s._v("MULTI")]),s._v("开启了一个事务之后，却因为断线而没有成功执行 "),a("code",[s._v("EXEC")]),s._v("，那么事务中的所有命令都不会被执行。")]),s._v(" "),a("li",[s._v("另一方面，如果客户端成功在开启事务之后执行 "),a("code",[s._v("EXEC")]),s._v("，那么事务中的所有命令都会被执行。")])])]),s._v(" "),a("li",[a("p",[a("code",[s._v("DISCARD")]),s._v("放弃执行事务")]),s._v(" "),a("ul",[a("li",[s._v("清空事务队列，并且客户端会从事务状态中退出")])])]),s._v(" "),a("li",[a("p",[a("code",[s._v("WATCH")])]),s._v(" "),a("ul",[a("li",[a("p",[a("code",[s._v("WATCH")]),s._v("某个key，如果被其他事务修改会结束执行返回nil-reply")])]),s._v(" "),a("li",[a("p",[s._v("使用check-and-set操作实现乐观锁")]),s._v(" "),a("div",{staticClass:"language- line-numbers-mode"},[a("pre",{pre:!0,attrs:{class:"language-text"}},[a("code",[s._v("WATCH mykey\nval = GET mykey\nval = val + 1\nMULTI\nSET mykey $val\nEXEC\n")])]),s._v(" "),a("div",{staticClass:"line-numbers-wrapper"},[a("span",{staticClass:"line-number"},[s._v("1")]),a("br"),a("span",{staticClass:"line-number"},[s._v("2")]),a("br"),a("span",{staticClass:"line-number"},[s._v("3")]),a("br"),a("span",{staticClass:"line-number"},[s._v("4")]),a("br"),a("span",{staticClass:"line-number"},[s._v("5")]),a("br"),a("span",{staticClass:"line-number"},[s._v("6")]),a("br")])])])])])])]),s._v(" "),a("li",[a("p",[s._v("事务中的错误")]),s._v(" "),a("ul",[a("li",[a("p",[s._v("执行事务之前，入队可能因为语法错误（参数数量错误，参数名错误，等等）或其他更严重的错误（内存不足）出错")]),s._v(" "),a("p",[s._v("判断返回值是否是"),a("code",[s._v("QUEUED")])])]),s._v(" "),a("li",[a("p",[s._v("调用"),a("code",[s._v("EXEC")]),s._v("之后出错（类型操作错误等）")])])])]),s._v(" "),a("li",[a("p",[s._v("多个事务执行逻辑")]),s._v(" "),a("p",[s._v("开启事务之后对应的操作会被缓冲到队列中，哪个事务的"),a("code",[s._v("EXCEC")]),s._v("先到达就先执行哪个事务的任务")])]),s._v(" "),a("li",[a("p",[s._v("为什么不支持回滚")]),s._v(" "),a("ul",[a("li",[s._v("Redis只会因为错误的语法失败（并且这些问题不能在入队时发现）或者命令用在错误的数据类型上。也就是说失败的命令是由错误编程造成的，这些问题应该在开发的过程中被发现，而不是生产环境")]),s._v(" "),a("li",[s._v("因为不需要回滚，所以Redis内部可以保持简单快捷")])])]),s._v(" "),a("li",[a("p",[s._v("check-and-set操作实现乐观锁")]),s._v(" "),a("div",{staticClass:"language- line-numbers-mode"},[a("pre",{pre:!0,attrs:{class:"language-text"}},[a("code",[s._v("WATCH mykey\nval = GET mykey\nval = val + 1\nMULTI\nSET mykey $val\nEXEC\n")])]),s._v(" "),a("div",{staticClass:"line-numbers-wrapper"},[a("span",{staticClass:"line-number"},[s._v("1")]),a("br"),a("span",{staticClass:"line-number"},[s._v("2")]),a("br"),a("span",{staticClass:"line-number"},[s._v("3")]),a("br"),a("span",{staticClass:"line-number"},[s._v("4")]),a("br"),a("span",{staticClass:"line-number"},[s._v("5")]),a("br"),a("span",{staticClass:"line-number"},[s._v("6")]),a("br")])]),a("blockquote",[a("p",[s._v("使用上面的代码， 如果在 "),a("code",[s._v("WATCH")]),s._v(" 执行之后， "),a("code",[s._v("EXEC")]),s._v(" 执行之前， 有其他客户端修改了 "),a("code",[s._v("mykey")]),s._v(" 的值， 那么当前客户端的事务就会失败。 程序需要做的， 就是不断重试这个操作， 直到没有发生碰撞为止。")]),s._v(" "),a("p",[s._v("这种形式的锁被称作乐观锁， 它是一种非常强大的锁机制。 并且因为大多数情况下， 不同的客户端会访问不同的键， 碰撞的情况一般都很少， 所以通常并不需要进行重试。")])])])]),s._v(" "),a("h2",{attrs:{id:"modules"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#modules"}},[s._v("#")]),s._v(" modules")]),s._v(" "),a("ul",[a("li",[a("p",[s._v("如何加载模块")]),s._v(" "),a("ul",[a("li",[a("p",[s._v("启动的时候通过参数指定加载")]),s._v(" "),a("p",[s._v("redis-server /etc/redis/6379.conf --loadmodule /path/xxx.so")])]),s._v(" "),a("li",[a("p",[s._v("配置文件中配置")]),s._v(" "),a("p",[s._v("loadmodule")])])])])]),s._v(" "),a("h3",{attrs:{id:"redisbloom布隆过滤器"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#redisbloom布隆过滤器"}},[s._v("#")]),s._v(" Redisbloom布隆过滤器")]),s._v(" "),a("p",[a("img",{attrs:{src:"/Users/lijinling/Documents/svn/myRepo/Coding/DayDayUp/Middleware/Cache/Redis/images/Redis_Bloom.png",alt:"image-20210713144303490"}})]),s._v(" "),a("ul",[a("li",[a("p",[s._v("配置使用")]),s._v(" "),a("ul",[a("li",[a("p",[s._v("访问redis.io->modules查找RedisBloom的"),a("a",{attrs:{href:"https://github.com/RedisBloom/RedisBloom",target:"_blank",rel:"noopener noreferrer"}},[s._v("github地址"),a("OutboundLink")],1)])]),s._v(" "),a("li",[a("p",[s._v("下载源码，解压安装")]),s._v(" "),a("ul",[a("li",[a("p",[s._v("unzip *.zip")])]),s._v(" "),a("li",[a("p",[s._v("make")])]),s._v(" "),a("li",[a("p",[s._v("cp bloom.so /opt/mashibing/redis5/")])])])]),s._v(" "),a("li",[a("p",[s._v("启动")]),s._v(" "),a("p",[s._v("redis-server --loadmodule  /opt/mashibing/redis5/redisbloom.so")])]),s._v(" "),a("li",[a("p",[s._v("使用")]),s._v(" "),a("p",[s._v("redis-cli")]),s._v(" "),a("p",[s._v("bf.add ooxx abc")]),s._v(" "),a("p",[s._v("bf.exits  abc")]),s._v(" "),a("p",[s._v("bf.exits sdfsdf")]),s._v(" "),a("p",[s._v("cf.add")])])])]),s._v(" "),a("li",[a("p",[s._v("架构")]),s._v(" "),a("ul",[a("li",[s._v("client实现bloom算法自己承载bitmap + Redis")]),s._v(" "),a("li",[s._v("client实现bloom算法 + Redis&bitmap")]),s._v(" "),a("li",[s._v("client + Redis&Bloom&bitmap")])])])]),s._v(" "),a("h3",{attrs:{id:"cukcoo布谷鸟过滤器"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#cukcoo布谷鸟过滤器"}},[s._v("#")]),s._v(" cukcoo布谷鸟过滤器")]),s._v(" "),a("h2",{attrs:{id:"lua脚本"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#lua脚本"}},[s._v("#")]),s._v(" Lua脚本")]),s._v(" "),a("h2",{attrs:{id:"lua脚本调试"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#lua脚本调试"}},[s._v("#")]),s._v(" Lua脚本调试")]),s._v(" "),a("h2",{attrs:{id:"内存优化"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#内存优化"}},[s._v("#")]),s._v(" 内存优化")]),s._v(" "),a("h2",{attrs:{id:"过期"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#过期"}},[s._v("#")]),s._v(" 过期")]),s._v(" "),a("ul",[a("li",[a("p",[s._v("过期时间的变化")]),s._v(" "),a("ul",[a("li",[s._v("过期时间不会随着访问而改变")]),s._v(" "),a("li",[s._v("如果发生写会剔除过期时间，需要业务逻辑去补全")])])]),s._v(" "),a("li",[a("p",[s._v("Redis如何淘汰过期的key")]),s._v(" "),a("ul",[a("li",[a("p",[s._v("过期两种方式")]),s._v(" "),a("ul",[a("li",[a("p",[s._v("被动访问时检测")]),s._v(" "),a("p",[s._v("当客户端尝试访问它时，key会被发现并且主动的过期")])]),s._v(" "),a("li",[a("p",[s._v("主动周期轮询判定")]),s._v(" "),a("p",[s._v("定时随机测试设置keys的过期时间，所有的这些过期的key将会从秘钥空间删除")]),s._v(" "),a("ol",[a("li",[s._v("测试随机的20个keys进行相关过期监测")]),s._v(" "),a("li",[s._v("删除所有已经过期的keys")]),s._v(" "),a("li",[s._v("如果有多于25%的key过期，重复步骤1")])]),s._v(" "),a("p",[a("strong",[s._v("这样的话在任何给定的时刻，最多会清楚1/4的过期keys")])])])]),s._v(" "),a("p",[a("strong",[s._v("这样做的目的是稍微牺牲下内存，但是保住了Redis性能")])])])])]),s._v(" "),a("li",[a("p",[s._v("在复制AOF文件时如何处理过期")])])]),s._v(" "),a("h2",{attrs:{id:"lrucache"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#lrucache"}},[s._v("#")]),s._v(" LRUCache")]),s._v(" "),a("h2",{attrs:{id:"从文件中批量导入数据"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#从文件中批量导入数据"}},[s._v("#")]),s._v(" 从文件中批量导入数据")]),s._v(" "),a("h2",{attrs:{id:"分区"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#分区"}},[s._v("#")]),s._v(" 分区")]),s._v(" "),a("h2",{attrs:{id:"分布式锁"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#分布式锁"}},[s._v("#")]),s._v(" 分布式锁")]),s._v(" "),a("h2",{attrs:{id:"key事件通知"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#key事件通知"}},[s._v("#")]),s._v(" key事件通知")]),s._v(" "),a("h2",{attrs:{id:"创建二级索引"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#创建二级索引"}},[s._v("#")]),s._v(" 创建二级索引")]),s._v(" "),a("h2",{attrs:{id:"客户端缓存"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#客户端缓存"}},[s._v("#")]),s._v(" 客户端缓存")])])}),[],!1,null,null,null);e.default=t.exports}}]);